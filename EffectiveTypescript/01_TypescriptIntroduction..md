# 타입스크립트 알아보기

## 1. 타입스크립트와 자바스크립트의 관계

> "Typescript(TS)는 Javascript(JS)의 Superset이다. "

아마도 TS를 접할 때 가장 처음에 듣는 말일 것이고 가장 기억에 남는 말이기도 하다. 일단 앞에서 서술한 대로 TS는 JS와 밀접한 관계를 가지며 이는 문법적으로도 그러하다. JS 프로그램에서 어떠한 이슈를 겪는다면 TS의 타입 체커에게도 지적받을 확률이 높다. 물론 타입 체커에 의해 지적을 받는다 하여도 이것이 동작하지 않는다는 의미는 아니나 이는 3번에서 자세히 다룰 것이다. 앞서 말한 문법적 유사성은 JS를 TS로 마이그레이션하는데 지대한 도움을 준다. 만약 어떠한 JS 프로그램을 다른 정적 타입 언어 프로그램으로 적고자 한다면 이를 새로 적는 것이 훨씬 나은 판단일 수 있으나 JS를 TS로 마이그레이션하는 것은 일단은 형식을 바꾸는 것으로부터 시작하며 이슈가 없는 JS를 TS로 바꾸는 것은 별 문제를 일으키지 않는다.

> "모든 JS 프로그램은 TS 프로그램이나 역은 성립하지 않는다."

```typescript
function greet(who: string) {
  console.log('Hello', who);
}
```

:string을 붙이면서 JS에서 TS로 가게 되고 이는 who라는 변수가 string 타입을 가지는 변수임을 알려줍니다. 이러한 방식으로 TS에게 who라는 변수의 타입을 추론하는데 도움이 되는 정보를 줄 수 있지만 타입 체킹 시스템 자체가 변수의 타입을 추론하기도 합니다. TS는 변수의 초깃값을 통해서 충분히 신뢰도 있게 변수의 타입을 추측할 수 있고 이를 통해 오류를 잡아낼 수 있습니다. 그러함에도 직접적으로 타입을 명시해주는 것은 TS의 타입 체킹 동작이 가지는 신뢰도를 높일 뿐 아니라 원하는 대로 흘러가는지 더 쉽게 TS가 잡아낼 수 있도록 합니다.

TS란 결국 JS의 런타임 동작을 모델링하는 타입 시스템을 가지고 있기에 최대한 런타임 내에서 발생할 오류를 잡고자 노력하나 이는 100%를 보장하지는 못합니다. 타입 체커를 통과하면서 실제 동작에서 오류를 발생하는 것은 충분히 가능한 일이고 그렇다 하더라도 TS는 타입으로 인해 발생하는 오류를 최소한으로 만들어줄 것입니다. 앞서 말한 TS를 사용함에도 발생하는 오류는 추후에 다시 한 번 예시를 통해 다루도록 하겠습니다.

## 2. 타입스크립트 설정 이해하기

TS는 다양한 조작가능한 설정들이 가능하고 이러한 설정들의 여부에 따라서 실제 코드에 많은 영향을 주게 됩니다. 이러한 TS 설정들을 커맨드를 통해서 사용해도 무관하나 대개는 tsconfig.json이라는 설정파일을 만들어서 관리하는 것을 권장합니다. 이는 tsc --init을 통해서 생성가능하며 이러한 설정파일을 사용함으로써 프로젝트에 적용중인 TS 설정들을 빠르게 확인할 수 있고 이를 동료나 검토하는 사람에게 쉽게 공유할 수 있습니다.

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"]
}
```

상기는 실제 TS 설정 파일 예시입니다. TS의 설정에는 실제 코드에 영향을 미치는 설정들이 있다고 말했고 이러한 설정 중에서 가장 중요한 것이 noImplicitAny strictNullChecks입니다.

먼저 noImplicitAny란 무엇인가에 대해서 알아보면, 타입스크립트 내에서 모든 변수들은 타입값을 가집니다. TS 프로그램을 짜는 프로그래머가 명시적으로 타입을 작성하던지 또는 TS가 타입을 any 또는 초기값을 통해 추론하든지 어떠한 타입을 가지게 됩니다. 이 중에서 any는 어떠한 타입으로도 사용될 수 있다는 의미로 이러한 any를 남용한다면 TS는 그 의미를 잃게 되며 더 나아가 any를 활용한 부분이 나머지 부분에 영향을 끼칠 수 도 있으므로 지양해야 합니다.

앞서 말한 TS가 any로 추론한 것을 암묵적 추론이라고 하며 이에 따른 암묵적 any를 금지하도록 하는 것이 noImplicitAny이며 TS를 제대로 사용하고자 한다면 해당 설정을 사용하는 것이 좋습니다. 해당 설정을 사용한 한 후에는 암묵적 Any가 에러를 발생하므로 명시적으로 any를 지정해주거나 더 좋은 것은 적절한 타입을 지정해주는 것이 좋습니다.

strictNullChecks는 모든 타입에서 null과 undefined가 허용되는지에 관한 설정입니다. 이 설정을 허용하기 전까지는 null, undefined가 모든 타입에 선언이 가능합니다.

```typescript
const str: number = null;
```

하지만 이 설정을 사용한 후로는 위와 같은 일을 하고 싶다면 명시적으로 표시해야 합니다.

```typescript
const str: number | null = null;
```

이러한 null, undefined 설정에 대한 엄격한 설정을 프로그램을 짜는 것에는 도움을 주지만 TS를 처음 도입하는 사람에게는 어렵게 느껴질 수 있기에 초심자는 이 설정을 사용하지 않고 진행해도 괜찮겠지만 이는 "undefined는 객체가 아닙니다"라는 끔찍한 오류를 경험하게 할 수 있기에 조심할 필요가 있습니다. 이러한 TS의 설정들을 전부 적용하고 싶다면 strict 설정을 도입할 필요가 있고 추가적으로 동료와 TS로 협업을 하면서 서로 다른 오류가 발생한다면 TS 설정을 확인하는 것이 도움이 될 수 있겠습니다.

## 3. 코드 생성과 타입은 관계가 없다

TS 컴파일러는 크게 2가지 역할을 수행합니다.

- 최신 TS/JS를 브라우저에서 동작할 수 있도록 구버전의 JS로 트랜스파일합니다.
- 코드의 타입 오류를 체크합니다.(타입 체커)

여기서 놀라운 것은 이 두 가지가 독립적이라는 사실입니다. 다시 말해 TS가 JS로 변환될 때 코드 내의 타입에 영향을 주지 않습니다. 또한 결과로 나오는 JS의 실행시점에도 타입은 영향을 미치지 않습니다.

이러한 일이 어떻게 일어나는 지에 대해 알기 위해 TS의 컴파일러가 어떠한 일을 하는지 알 필요가 있습니다.

> TS는 타입 오류가 있는 코드도 컴파일이 가능합니다.

이 부분이 제게는 알면서 몰랐던 것입니다. React + TS로 컴파일을 진행하면서 에러가 발생하더라도 일단 컴파일은 진행되는 현상을 많이 발견하였는데 별 생각이 없었는데 이 부분에서 그에 대한 이유를 알 수 있었습니다. 일단 타입에 오류가 있더라도 컴파일이 되는 것이 엉성한 언어처럼 보일 수 있지만 이는 실제로는 도움이 됩니다. 오류가 발생하여 아직 수정하지 않은 상태더라도 상기의 특징 덕분에 나머지 부분에 대해서 테스트를 진행할 수 있기 때문입니다. 이러한 오류가 있을 때 컴파일을 진행하고 싶지 않다면 *noEmitOnError*를 tsconfig.json에 설정하면 되겠습니다.

> 런타임에는 타입 체크가 불가능합니다.

지금 보기에는 이것이 당연해보일 수 있지만 이전에 TS에 대한 공부를 제대로 진행하지 않고 사용할 때는 당연히 실행중에도 정적 타입이 보장된다고 생각했습니다. 하지만 런타임에는 TS의 정적 타입 체킹은 불가능합니다. 이에 대한 근본적인 이유는 결국 브라우저에서 돌아가는 것은 JS이고 TS는 결국 JS로 변환이 되기 때문입니다. 결국 TS는 JS로 변환되고 이 과정에서 인터페이스, 타입 등 TS의 타입과 관련된 구문은 전부 제거됩니다.

그렇다면 실제 실행중에는 타입 체킹을 어떻게 진행하는가?

이를 가능케 하는 것에는 여러 가지가 있지만 그 중에서 괜찮은 것은 태그를 사용하는 것입니다. 타입을 문자열 형식으로 실제로 저장하도록 하거나 특정 타입에만 존재하는 속성의 유무를 판단하거나 이를 발전시켜서 Class에 이러한 내용을 포함시키는 방식으로 우리가 원하는 바를 이룰 수 있습니다.

> 타입 연산은 런타임에 영향을 주지 않습니다.

TS의 타입연산 as number 등은 실제 변환되는 JS 코드에 아무런 영향을 끼치지 못하며 값을 정제하기 위해서는 런타임의 타입을 체크해야 하고 JS 연산을 통해 변환을 수행해야 합니다.

> 런타임 타입은 선언된 타입과 충분히 다를 수 있습니다.

타입스크립트의 타입은 런타임에서 제거되기에 런타임에서 해당 타입임을 보장할 수 없습니다. 런타임 상에서 타입이 달라지는 혼란스러운 상황은 최대한 피하는 것은 좋습니다. 언제나 달라질 수 있음을 명시해야 합니다.

> TS 타입으로는 함수를 오버로드할 수 없습니다.

C++ 같은 언어는 동일한 함수 이름에 매개변수만 다른 여러 버전의 함수를 사용 가능하고 이를 함수 오버로딩이라고 합니다. 그러나 TS에서는 타입과 런타임의 동작이 무관하기에 함수 오버로딩은 불가능합니다. TS에서 함수 오버로딩을 지원하긴 하지만 온전히 타입 수준(TS)에서만 동작하고 구현체는 오직 하나입니다.

> TS 타입은 런타임 성능에 영향을 주지 않습니다.

TS의 타입 연산자는 JS로의 변환에서 제거되기 떄문에 런타임 성능에는 아무런 영향을 주지 않으나 별도의 시간이 필요하긴 합니다.

- 런타임 오버헤드가 없는 대신 TS 빌드타임 오버헤드가 있습니다. TS 빌드타임 오버헤드가 크다고 느껴진다면 트랜스파일만 빌드하도록 설정하여 타입 체크를 건너뛸 수 있습니다.

## 4. 구조적 타이핑(Duck Typing) 익숙해지기

## 5. any 타입 지양하기
