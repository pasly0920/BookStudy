# 타입스크립트의 타입 시스템

## 6. 편집기를 활용하여 타입 시스템 탐색하기

타입 스크립트를 실행하면 두 가지를 실행할 수 있습니다.

- 타입스크립트 컴파일러 tsc
- 단독으로 실행 가능한 타입스크립트 서버 tsserver

보통은 tsc를 사용하는 것이 주된 목적이지만 tssserver 역시 언어 서비스를 제공한다는 점에서 중요합니다. 보통은 편집기에서 언어 서비스를 사용하는데 tsserver에서도 언어 서비스를 제공하도록 설정하도록 하는 것이 좋습니다. 자동완성 서비스를 사용하면 타입스크립트 코드 작성이 간편해집니다. 이러한 서비스를 차치하더라도 편집기는 코드를 빌드하고 타입 시스템을 익힐 수 있는 최고의 수단입니다.

편집기마다 조금씨기 다르지만 보통의 경우에는 심벌 위에 마우스 커서를 대면 타입스크립트가 타입을 어떻게 판단하고 있는지 확인할 수 있습니다. 특정 시점에서 타입스크립트가 타입을 어떻게 이해하는지는 타입 넓히기 & 좁히기를 위해서 필수적으로 필요한 과정입니다. 조건문의 분기에서 타입이 어떻게 변하는지 살펴보는 것은 타입 시스템을 연마하는 매우 좋은 방법입니다.

> 타입 스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 터득해야 합니다.

## 7. 타입이 값들의 집합이라고 생각하기

런타임에 모든 변수는 JS 세상에서 각자의 고유한 값을 가지며 변수에는 다양한 값을 할당할 수 있습니다.

그러나, 코드가 실행되기 전, 즉 TS가 오류를 체크하는 순간에는 타입을 가지고 있습니다. 타입은 _'할당 가능한 값들의 집합'_ 이라고 생각하면 됩니다. 이 집합은 타입의 범위라고 부르기도 합니다.

이러한 범위를 우리는 집합으로 치환 가능합니다.

가장 작은 집합은 아무것도 포함하지 않는 공집합으로 TS에서 never타입입니다. never 타입으로 선언된 변수의 범위는 공집합이기에 어떠한 값도 할당할 수 없습니다.

```typescript
const x: never = 12;
// ~ '12' 형식은 'never'형식에 할당할 수 없습니다.
```

그 다음으로 가장 작은 집합은 한가지 값만 포함하는 타입입니다. 이들은 TS에서 유닛 타입이라고도 불리는 리터럴 타입입니다.

```typescript
type A = "A";
type B = "B";
type Twelve = 12;
```

이러한 유닛 타입들을 두 개 혹은 세 개 또는 그 이상을 위해서는 유니온 타입을 사용합니다.
유니온 타입은 값 집합들으 합 집합을 의미합니다.

```typescript
type AB = "A" | "B";
const a: AB = "A";
const c: AB = "C";
// ~ "C" 형식은 'AB'형식에 할당할 수 없습니다.
```

다양한 타입스크립트 오류에서 할당 가능한 이라는 문구를 볼 수 있습니다. 이 문구는 집합의 관점에서 '~의 원소(값과 타입의 관계)' 또는 '~의 부분집합(두 타입의 관계)'를 의미합니다. 위의 예시에서 'C'는 AB의 부분집합이 아니므로 오류입니다.
집합의 관점에서 타입 체커의 역할은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것이라고 볼 수 있습니다.

앞 코드들의 타입은 집합의 범위가 한정되어 있기에 쉽게 이해할 수 있습니다. 하지만 실제 다루게 되는 타입은 대부분 범위가 무한대이므로 이해하기 훨씬 어려울 수 있습니다.

다음의 부분은 중요하다고 생각됩니다. (이 정리글의 필자가 생각하는!)

연산과 관련된 이해를 돕기 위해서 값의 집합을 타입이라고 생각해 봅시다.

```typescript
interface Person {
  name: string;
}

interface LifeSpan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person & LifeSpan;
```

& 연산자는 두 타입의 intersection(교집합)을 계산합니다. 언뜻 보기에 Person과 LifeSpan 인터페이스는 공통으로 가지는 속성이 없기에 PersonSpan 타입을 공집합(never 타입)으로 예상하기 쉽습니다. 필자 역시 같은 생각이었습니다. 그러나 타입 연산자는 인터페이스의 속성이 아니라, 값의 집합(타입 범위)에 적용됩니다. **그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속합니다.**

바로 앞의 문장이 잘 이해가 안 가기는 하지만 이로 인해서 Person과 LifeSpan을 둘 다 가지는 값은 Intersection 타입에 속하게 됩니다.

```typescript
const ps: PersonSpan = {
  name = "alan Turing",
  birth = new Date("1912/03/23"),
  death = new Date("1911/02/33"),
};
```

앞의 세가지보다 더 많은 속성을 가지는 값도 PersonSpan 타입에 속합니다. Intersection 타입의 값은 각 타입 내의 속성을 모두 포함하는 것이 일반적인 규칙입니다.

규칙이 속성에 대한 인터섹션에서는 맞지만, 두 인터페이스의 유니온에서는 그렇지 않습니다.

```typescript
type K = keyof (Person | LifeSpan); // 타입이 never
```

앞의 유니온 타입에 속하는 값은 어떠한 키도 없기 떄문에 유니온에 대한 keyof는 공집합이어야만 합니다.

여기서 이제 중요한 식을 만나게 됩니다.

> ```typescript
>   keyof (A&B) = (keyof A) | (keyof B)
>   keyof (A|B) = (keyof A) & (keyof B)
> ```

본 등식은 TS의 타입 시스템을 이해하는 데 큰 도움이 될 것입니다.

조금 더 일반적으로 PersonSpan 타입을 선언하는 방법은 extends 키워드를 사용하는 것입니다.

```typescript
interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

타입이 집합이라는 관점에서 extends의 의미는 '~에 할당 가능한'과 비슷하게 '~의 부분집합'이라는 의미로 받아들일 수 있습니다.PersonSpan 타입의 모든 값은 문자열 name 속성을 가져야 합니다.

위의 |, & 로 연결된 타입들에 대해서 한 번 더 살펴보도록 하겠습니다.

1. 교차 타입

   다양한 타입을 하나로 결합해서 모든 기능을 갖춘 단일 타입을 얻는 방법입니다. 예를 들어 Person & Serializable & Loggable은 Person, Serializable, Loggable의 모든 멤버를 가집니다.

2. 유니온 타입

   유니온 타입은 이름으로 유추했을 때 오히려 교차 타입의 동작을 따라야 할 것 같습니다. 하지만 유니온 타입의 동작은 교차타입의 그것과는 다릅니다. 간단하게 표현할 수 있습니다. | 은 or이라는 키워드와 대응되고 이를 타입에 적용한 것입니다. string | number라고 한다면 string, number일 것이고 이것이 하나의 타입이 되는 것입니다. 유니온 타입은 | 로 연결된 모든 멤버들이 공통적으로 가지는 공통적인 멤버에만 접근할 수 있습니다.

간단 정리

- 타입을 값의 집합으로 생각하면 이해하기 편합니다.

- TS의 타입은 엄격한 상속관계가 아니라 겹쳐지는 집합(벤 다이어그램)으로 표현합니다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있습니다.

## 8. 타입 공간과 값의 심벌 구분하기

## 9. 타입 단언보다는 타입 선언 사용하기

## 10. 객체 래퍼 타입 피하기

## 11. 잉여 속성 체크의 한계 인지하기

## 12. 함수 표현식에 타입 적용하기

## 13. 타입과 인터페이스의 차이점 알기

## 14. 타입 연산과 제너릭 사용으로 반복 줄이기

## 15. 동적 데이터에 인덱스 시그니처 사용하기

## 16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

## 17. 변경 관렫된 오류 방지를 위해 readonly를 사용하기

## 18. 매핑된 타입을 사용하여 값을 동기화하기
